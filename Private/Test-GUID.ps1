#region: Notes
<#
# HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Installer\UserData\S-1-5-18\Products\
# 906F89D8-00DA-3583-8057-A7425FB9FDD4
# ...becomes
# 8D98F609-AD00-3853-0875-7A24F59BDF4D
# > Original GUID order...
# 01234567-0123-0123-0123-0123456789AB
# > Swapped GUID order (little-endian)
# 76543210-3210-3210-1032-1032547698BA
# > Full array order (little-endian)
# 7 6 5 4 3 2 1 0 - 11 10 9 8 - 15 14 13 12 - 17 16 19 18 - 21 20 23 22 25 24 27 26 29 28 31 30
# NOTE: Guid.ToString('X') outputs... a string. lame.
# {0x906f89d8,0x00da,0x3583,{0x80,0x57,0xa7,0x42,0x5f,0xb9,0xfd,0xd4}}
# Target
# {0x8d98f609,0xad00,0x3853,{0x08,0x75,0x7a,0x24,0xf5,0x9b,0xdf,0x4d}}

# Terminal custom profile namespace GUID
# {F6 5D DB 7E - 70 6B - 44 99 - 8A 50 - 40 31 3C AF 51 0A}
# {01 23 45 67 - 89 AB - CD EF - A0 A1 - A2 A3 A4 A5 A6 A7}
# .NET System.Guid Little Endian byte[] representation
# {7E DB 5D F6 - 6B 70 - 99 44 - 8A 50 - 40 31 3C AF 51 0A}
# {67 45 23 01 - AB 89 - EF CD - A0 A1 - A2 A3 A4 A5 A6 A7}

# Standard Terminal GUID Example
# Requires: Fragment Namespace, App Namespace, Profile Name
# Profile/Fragment Namespace: {f65ddb7e-706b-4499-8a50-40313caf510a}
# App Namespace: Terminal Namespace + 'Git' = {?}
# Profile GUID: App Namespace + 'Git Bash' = {2ece5bfe-50ed-5f3a-ab87-5cd4baafed2b}

# Automatically Generated by Terminal
# Internal Namespace: {2bde4a90-d05f-401c-9492-e40884ead1d8}
# Profile GUID: NS + 'Ubuntu' = {2c4de342-38b7-51cf-b940-2309a097f518}

# guid.ParseExact(string, format)
# https://learn.microsoft.com/en-us/dotnet/api/system.guid.parseexact?view=netframework-4.8.1#system-guid-parseexact(system-string-system-string)
# Format specifier
# N: 32 hex digits      - 00000000000000000000000000000000
# D: N w/ hyphens       - 00000000-0000-0000-0000-000000000000
# B: D w/ braces        - {00000000-0000-0000-0000-000000000000}
# P: D w/ parantheses   - (00000000-0000-0000-0000-000000000000)
# X: 4 hex values in braces matching the pattern {0x32b,0x16b,0x16b,{0x8b,(...x6...),0x8b}}
#>
#endregion: Notes

# $script:LITTLEENDIAN = [System.BitConverter]::IsLittleEndian

# this is fucking dumb
function private:fmt {
    Param(
        [Parameter(
            Position=0,
            Mandatory,
            ValueFromPipeline
            )]
        [byte[]]$Bytes,
        [Parameter(
            Position=1,
            ValueFromPipeline,
            ValueFromRemainingArguments
            )]
        [string[]]$Text
    )
    Begin {
        if($Text.Count -gt $Bytes.Count) {
            Throw [System.Management.Automation.PSArgumentOutOfRangeException]::new('Text',
                $Text.Count,
                "The 'Text' parameter must contain an equal or lesser number of elements as 'Bytes' ($($Bytes.Count))")
        }
    }
    Process {
        # get binary formats, padded to 8
        $BtBins = $Bytes.ForEach{[convert]::ToString($_, 2).PadLeft(8, '0')}
        # get longest text length
        if($Text) {
            $Maxlen = $Text | Sort-Object Length -Descending | Select-Object -First 1 -expand Length
            $TxtFmt = "{0,-$Maxlen}"
        } else {
            # if no text passed, default to the byte index
            $TxtFmt = "{0,-2}"
        }

        for($i=0; $i -le $Bytes.GetUpperBound(0); $i++) {
            # get binary index
            $bt = $Bytes[$i]
            $bin = [convert]::ToString($bt, 2).PadLeft(8, '0')

            if($Text) {
                if($Text.GetUpperBound(0) -gt $i) {
                    $txt = $Text[$i]
                } else {
                    # in case the text.ubound is > the count,
                    $iabs = [math]::Abs($Text.GetUpperBound(0)-$i)
                    $txt = $Text[[math]::Min($iabs, $i)]
                }
            } else {
                $txt = $bt
            }

            "$TxtFmt : 0x{1:X2} == 0b{2}" -f $txt, $bt, $bin
        }
    }
}

# NO: this loops through the bytes. screw that.
function private:testreverseguid {
    Param(
        # GUID will be converted based on endianness
        [guid]
        $Guid = '906F89D8-00DA-3583-8057-A7425FB9FDD4',
        # specify to also reverse bytes to LSO
        [switch]
        $LeastSignificant
    )

    # the bytes will be reversed like
    # {67 45 23 01 - 23 01 - 23 01 - 01 23 - 01 23 45 67 89 AB}
    if($IsCoreCLR) {
        $guidbytes = $guidtest.ToByteArray($script:LITTLEENDIAN)
    } else {
        $guidbytes = $guidtest.ToByteArray()
        # manually swap
        if($script:LITTLEENDIAN) {
            $guidbytes = $guidbytes[3..0] + $guidbytes[5,4] + $guidbytes[7,6] + $guidbytes[8..15]
        } else {
            $guidbytes = $guidbytes[3..0] + $guidbytes[5,4] + $guidbytes[7,6] + $guidbytes[8..15]
        }
    }

    if($LeastSignificant) {
        # loop through each byte
        $guidbytes.ForEach{
            # get a bit array which is a useful fuck type that didn't implement ToString.
            # AND YET CORE HAS RIGHTSHIFT & LEFTSHIFT METHODS. fucking kill me, seriously. I'm tired of living
            $bitarr = [System.Collections.BitArray]::new($_)
            $sum = 0
            # loop through each bit... obviously this would be easy to reverse
            for($i=0; $i -lt $bitarr.Count; $i++) {
                # if the bit is 1, add its value
                if($bitarr[$i]) {
                    $sum += [math]::Pow(2, $i)
                    # reverse method
                    $sum += [math]::Pow(2, ($bitarr.Count-$i-1))
                }
            }
            # add the total
            $guidbytes2 += $sum
            $_ = $guidbytes2
        }
    }
    [guid]::new($guidbytes)
}

# NOTE: Found in Conversion module, on which GUIDex is dependent
<# Unused / old functions
# original:     906F89D8-00DA-3583-8057-A7425FB9FDD4
# tobytearray(), 3-0, 5-4, 7-6, 8-15
# new guid w/ above
# converted:    8d98f609-ad00-3853-0875-7a24f59bdf4d
function Convert-Byte {
    [OutputType([byte[]])]
    [CmdletBinding()]
    Param(
        [Parameter(
            Position=0,
            ValueFromPipeline
        )]
        [byte[]]$byte
    )
    Begin {
        $local:VERBOSE = $MyInvocation.BoundParameters.ContainsKey('Verbose')

        # "Pipeline len: "+$MyInvocation.PipelineLength+", pos: "+$MyInvocation.PipelinePosition | Write-Verbose
    }

    Process {
        foreach($b in $byte) {
            [byte]$High   = ($b -shr 4) -band 0x0F
            [byte]$Low    = $b -band 0x0F
            # 0xB0, 0b10110000
            [byte]$LowEx  = $Low -shl 4
            # 0xB3, 0b10110011
            [byte]$result = $High -bor $LowEx

            if($local:VERBOSE) {
                local:fmt -Text 'Byte','High 4b','Low 4b','Result' -Bytes $b,$High,$LowEx,$result | Write-Verbose
            }
            # Byte  : 0x3B, 0b00111011
            # High  : 0x03, 0b0011
            # Low   : 0xB0, 0b10110000
            # Res   : 0xB3, 0b10110011
            $result
        }
    }
}

# TODO: For byteswapping in PS5.1, try importing from .NET Core
# https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Guid.cs
#   specifically, the constructor overload
#       guid    new(ReadOnlySpan[byte] b, bool bigEndian)
#   and the methods...
#       byte[]  ToByteArray(bool bigEndian)
#       bool    TryWriteBytes(System.Span[byte] destination, bool bigEndian, [ref] int bytesWritten)

# TODO: Perhaps try using this for GUID conversion...
function UInt32ToBigEndianBytes {
    [OutputType([byte[]])]
    Param(
        [Parameter(
            Position=0,
            ValueFromPipeline
        )]
        [UInt32]
        $UInt32
    )

    Process {
        $Result = [BitConverter]::GetBytes($UInt32)

        if($script:LITTLEENDIAN) {
            [array]::Reverse($Result)
        }

        $Result
    }
}

# see: Convert-UUIDBytes.ps1
# Flips GUID byte array between little- and big-endianness
# TODO: Test performance vs. ByteswapGuid()
# done: STANDARDIZE FUNC
#   [x]: PARAM BLOCK
#   [x]: PIPELINE SUPPORT
#   [x]: PROCESS BLOCK
# NOTE: Renamed Convert-UUIDBytes
function BSGUID {
    [OutputType([byte[]])]
    Param(
        [Parameter(
            Mandatory,
            Position=0,
            ValueFromPipeline
        )]
        [byte[]]$GUID,
        [ValidateSet('Class','ShortOrder','LongOrder')]
        $Method = 'ShortOrder'
    )

    Process {
        switch ($Method) {
            'Class' { # method 1: create new GUID, return as byte[] with bigendian = True
                if($PSEdition -eq 'Core') {
                    $NewGUID = [guid]::new($GUID, $script:LITTLEENDIAN)
                } else {
                    Throw [System.PlatformNotSupportedException]::new("GUID constructor overload is only available in PowerShell Core.")
                }
            }
            'ShortOrder' { # method 2: constructing the bytes in order
                [byte[]]$NewGUID = $GUID[3..0] + $GUID[5..4] + $GUID[7..6] + $GUID[8..15]
            }
            'LongOrder' { # method 3: laborious, hard-to-follow method
                # swap 1st and 4th bytes
                [byte]$temp = $GUID[0]
                $GUID[0] = $GUID[3]
                $GUID[3] = $temp
                # swap 2nd and 3rd bytes
                $temp = $GUID[1]
                $GUID[1] = $GUID[2]
                $GUID[2] = $temp
                # swap 5th and 6th bytes
                $temp = $GUID[4]
                $GUID[4] = $GUID[5]
                $GUID[5] = $temp
                # swap 7th and 8th bytes
                $temp = $GUID[6]
                $GUID[6] = $GUID[7]
                $GUID[7] = $temp
                $NewGUID = $GUID
            }
        }

        # "Method {0} took {1:n3}ms" -f $Method,$Timer.TotalMilliseconds | Write-Host
        Return $NewGUID
    }
}

# see: Convert-UUID.ps1
# P1: Test functionality (Pester?)
# BUG: creating a guid from byte[] with manually swapped order un-swaps it...
#   in PS 5.1, or in PS7 if BigEndian = False
# TODO: Test performance vs. BSGUID()
# TODO: Add option to convert to... whatever the MSI Installer product GUID is
# TODO: STANDARDIZE
#   [x]: PARAM BLOCK
#   [x]: PIPELINE SUPPORT
#   [x]: PROCESS BLOCK
function Convert-GUIDBytes {
    [Alias('ByteswapGuid')]
    [OutputType([System.Guid])]
    [CmdletBinding()]
    Param(
        [Parameter(
            Position=0,
            ValueFromPipeline,
            ValueFromPipelineByPropertyName
        )]
        [guid]
        $GUID,
        # swaps the low/high 4-bit order of bytes
        [switch]
        $Reverse,
        [switch]
        $RespectBitOrder
    )

    Process {
        # create temp var to work with and check data type
        Write-Verbose "Convert-GUIDBytes - Type = $($GUID.GetType())"

        if($GUID -is [guid]) {
            # convert GUID to bytearray first
            $TempVar = $GUID.ToByteArray()
        } elseif($GUID -is [byte[]]) {
            $TempVar = $GUID
            # check byte length
            if($TempVar.Length -ne 16) {
                Throw [System.Management.Automation.ErrorRecord]::new([System.TypeLoadException]::new("Unexpected byte[] length of $($TempVar.Length) != 16."), 3,'InvalidData', $GUID)
            }
        } else {
            Throw [System.Management.Automation.ErrorRecord]::new([System.TypeLoadException]::new("Unexpected data type $($GUID.GetType()) != Byte[] or Guid."), 4,'InvalidType', $GUID)
        }

        # easy method
        # reverse first 4 bytes, next 2 by 2, and append the last 8 normally
        if($Reverse) {
            Write-Verbose "-Reverse specified. Creating low/high swapped bytes according to LE = $script:LITTLEENDIAN"
            if($script:LITTLEENDIAN -and $RespectBitOrder) {
                # [guid] will reverse the order if LE, it seems
                [byte[]]$TempBytes = $TempVar | Convert-Byte
            } else {
                # reverse manually if BE
                $TempBytes = [byte[]]::new(0)
                # For [guid]::New(int32, int16, int16, byte[]) method so the damn order is respected
                [UInt32]$GUIDInt32 = 0
                [UInt16]$GUIDInt16A = 0
                [UInt16]$GUIDInt16B = 0
                $GUIDBytes = [byte[]]::new(8)
                $Position = 0
                $TempVar[0..3] | Convert-Byte | % {
                    $Mask = $Position*8
                    $GUIDInt32 += $PSItem -shl $Mask
                    $Position++
                }
                $Position = 0
                $TempVar[4..5] | Convert-Byte | % {
                    $Mask = $Position*8
                    $GUIDInt16A += $PSItem -shl $Mask
                    $Position++
                }
                $Position = 0
                $TempVar[6..7] | Convert-Byte | % {
                    $Mask = $Position*8
                    $GUIDInt16B += $PSItem -shl $Mask
                    $Position++
                }
                $GUIDBytes = $TempVar[8..15]

                # $TempBytes += $TempVar[3..0] | Convert-Byte
                # $TempBytes += $TempVar[5..4] | Convert-Byte
                # $TempBytes += $TempVar[7..6] | Convert-Byte
                # $TempBytes += $TempVar[8..15] | Convert-Byte
            }
        } else {
            Write-Verbose "Creating bytes according to LE = $script:LITTLEENDIAN"
            if($script:LITTLEENDIAN -and $RespectBitOrder) {
                # [guid] will reverse the order if LE, it seems
                [byte[]]$TempBytes = $TempVar
            } else {
                # reverse manually if BE
                [byte[]]$TempBytes = $TempVar[3..0] + $TempVar[5..4] + $TempVar[7..6] + $TempVar[8..15]
            }
        }

        Write-Verbose "Setting [$($GUID.GetType())]`$GUID as the modified byte array..."
        # update passed reference with new value
        if($GUID -is [guid]) {
            # create new GUID and set to the passed var
            if($RespectBitOrder) {
                $GUID = [guid]::new($TempBytes)
            } else {
                $GUID = [guid]::new($GUIDInt32, $GUIDInt16A, $GUIDInt16B, $GUIDBytes)
            }
        } else {
            # otherwise, just assign the swapped byte array
            $GUID = $TempBytes
        }

        Return $GUID
    }
}

# see: New-UUIDNamespace.ps1
# Create UUID v3 or v5 from a namespace and string
# thanks https://github.com/icosa-foundation/open-brush/blob/78cc38cb172649340eb61eec3d3d38f7f289069c/Assets/Scripts/Util/GuidUtils.cs
# TODO: TEST w/ Pester using the Terminal documentation
# TODO: STANDARDIZE FUNC
#   [ ]: PIPELINE + PROCESS BLOCK
function New-NamespaceGUID {
    [CmdletBinding()]
    [OutputType([System.Guid])]
    param (
        [Guid]
        $NS,
        [string]
        $Name,
        [ValidateSet(3, 5)]
        [int]
        $Version = 5
    )

    $Hasher = if($Version -eq 5) {
        # alternately takes a string HashName
        [System.Security.Cryptography.SHA1]::Create()
    } elseif($Version -eq 3) {
        # also takes a string AlgName
        [System.Security.Cryptography.MD5]::Create()
    } else {
        Throw [System.Exception]::new("Unrecognized UUID version $Version")
    }

    # get GUID as big endian byte[] (16ms)
    if($IsCoreCLR) {
        $NSBytesBigEndian = $NS.ToByteArray($true)
    } else {
        $NSBytesBigEndian = $NS.ToByteArray()
        $NSBytesBigEndian = Convert-GUIDBytes $NSBytesBigEndian
    }
    # convert to big endian... uh... $NSBytesBigEndian.ToByteArray($true) ???
    # ByteswapGuid ([ref]$NSBytesBigEndian)

    # where does this go...?
    [void]$Hasher.TransformBlock($NSBytesBigEndian, 0, $NSBytesBigEndian.Length, $null, 0)

    # get unicode bytes of string
    $UTF8Name = [System.Text.Encoding]::UTF8.GetBytes($Name)
    # transform... something
    [void]$Hasher.TransformFinalBlock($UTF8Name, 0, $UTF8Name.Length)

    # create 16-byte var to hold the crypt hash
    $Hash16 = [byte[]]::new(16)
    # Copy(arr Source, int SourceIndex, arr Dest, int DestIndex, int length)
    # TODO: Try Copy(arr Source, arr Dest, int length)
    [System.Array]::Copy($Hasher.Hash, 0, $Hash16, 0, $Hash16.Length)

    # see: https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_arithmetic_operators?view=powershell-7.4#bitwise-operators

    # RFC4122... Octet 8, clock_seq_hi_and_reserved, top 3 bits to 1 0 x
    # from (byte)((hash16[8] & ~0xc0) | 0x80)
    # ~0xC0 is the complement of 192, i.e. 63
    $Hash16[8] = [byte](($Hash16[8] -band (-bnot 0xC0)) -bor 0x80)
    # Version... most-significant 4 bits of time_hi_and_version (octets 6,7)
    # from (byte)((hash16[6] & ~0xf0) | (version << 4))
    # ~0xF0 is the complement of 0b11110000, i.e. 15, 0b1111
    # TODO: See how it's done in .NET Core [System.Numerics.BitOperations]::RotateLeft(), RotateRight()
    $Hash16[6] = [byte](($Hash16[6] -band (-bnot 0xF0)) -bor ($Version -shl 4))

    # convert back to little-endian
    $Hash16 = Convert-GUIDBytes $Hash16
    # create final GUID
    $ReturnGUID = [System.Guid]::new($Hash16)

    Return $ReturnGUID
}

# see: New-UUID.ps1
function Get-UUIDv5 {
    param (
        [Parameter(Mandatory=$true)]
        [Guid]$Namespace,

        [Parameter(Mandatory=$true)]
        [string]$Name
    )

    Begin {
        $LITTLE_ENDIAN = [System.BitConverter]::IsLittleEndian
    }

    Process {
        # Convert the namespace GUID to a byte array, keeping the endianness from swapping
        $namespaceBytes = $Namespace.ToByteArray($LITTLE_ENDIAN)

        # Convert the name to a byte array
        $nameBytes = [System.Text.Encoding]::UTF8.GetBytes($Name)

        # Combine namespace and name
        $combinedBytes = $namespaceBytes + $nameBytes

        # Create a SHA1 hash
        $sha1 = [System.Security.Cryptography.SHA1]::Create()
        # toss the last 4 bytes
        $hashBytes = $sha1.ComputeHash($combinedBytes)[0..15]

        # Set the version (5) and variant bits
        $hashBytes[6] = ($hashBytes[6] -band 0x0F) -bor 0x50
        $hashBytes[8] = ($hashBytes[8] -band 0x3F) -bor 0x80

        # verify it's a byte array and not a generic object[]
        $hashBytes = $hashBytes -as [byte[]]

        # Create a new GUID from the hash
        $uuidv5 = [Guid]::New($hashBytes, $LITTLE_ENDIAN)
        return $uuidv5
    }

    End {
        $sha1.Dispose()
    }
}
 #>
